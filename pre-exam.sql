CREATE TABLE Programmer(
    id INT PRIMARY KEY,
    email VARCHAR(200) UNIQUE
);

CREATE TABLE TestCase(
    id INT PRIMARY KEY,
    testName VARCHAR(100) UNIQUE
);

CREATE TABLE Pipeline(
    id INT PRIMARY KEY,
    programmer INT,
    FOREIGN KEY (programmer) REFERENCES Programmer(id)
);

CREATE TABLE TestRun(
    id INT PRIMARY KEY,
    pipeline INT,
    testCase INT,
    result VARCHAR(16),
    FOREIGN KEY(pipeline) REFERENCES Pipeline(id),
    FOREIGN KEY(testCase) REFERENCES TestCase(id)
);

INSERT INTO Programmer(id, email) VALUES
    (1, 'ivan@gmail.com'),
    (2, 'petar@gmail.com'),
    (3, 'gosho@abv.bg');
    
    
INSERT INTO TestCase(id, testName) VALUES
    (1, 'Service A'),
    (2, 'Service B');
    
INSERT INTO Pipeline(id, Programmer) VALUES
    (1, 1),
    (2, 1),
    (3, 2);
    
INSERT INTO TestRun(id, pipeline, testCase, result) VALUES
    (1, 1, 1, 'success'), -- Service A
    (2, 1, 2, 'success'), -- Service B
    
    (3, 2, 1, 'fail'),    -- Service A
    (4, 2, 2, 'cancled'), -- Service B
    
    (5, 3, 1, 'success'), -- Service A
    (6, 3, 2, 'fail');    -- Service B

-- Order all the Programmers by theier number of Pipelines.    
SELECT
    Programmer.email as email,
    COUNT(Pipeline.id) as pipelines
FROM Programmer LEFT JOIN Pipeline ON Pipeline.programmer = Programmer.id
GROUP BY Programmer.id
ORDER BY pipelines DESC;

-- Find all the users with most number of Pipelines.
WITH
    Pipelines AS (
        SELECT
            Programmer.email,
            COUNT(Pipeline.id) as pipelines
        FROM Programmer LEFT JOIN Pipeline ON Pipeline.programmer = Programmer.id
        GROUP BY Programmer.id
        ORDER BY pipelines DESC
    )
SELECT 
    *
FROM Pipelines
WHERE pipelines = (
    SELECT MAX(pipelines) FROM Pipelines
);

-- Find the number of successful TestRuns for each Programmer.
-- Solution in plain English:
-- For every Programmer's TestRun (The FROM SQL clause)
-- Leave only those runs that are 'success' if the Programmer has TestRuns
--                                             or keep the NULL padded record
--                                             generated by the left joins if
--                                             the Programmer does not have any
--                                             TestRun!
-- Group those records by Programmer and count the TestRuns (TestRun.id)!
-- The result is:
-- ivan@gmail.com, 2 (The 2 come from Pipeline with id 1)
-- petar@gmail.com, 1 (The 1 is from the 'Service A' TestCase for Pipeline 3)
-- gosho@abv.bg, 0 (gosho@abv.bg does not have any TestRun!)                             
SELECT
    Programmer.email,
    COUNT(TestRun.id) as successes
FROM
    Programmer LEFT JOIN Pipeline ON Programmer.id = Pipeline.programmer
               LEFT JOIN TestRun ON  TestRun.Pipeline = Pipeline.id
WHERE TestRun.result = 'success' OR TestRun.result IS NULL
GROUP BY Programmer.id;

-- Find the number of unsuccessful TestRuns for each Programmer.
-- Solution in plain English:
-- For every Programmer's TestRun (The FROM SQL clause)
-- Leave only those runs that are not 'success' if the Programmer has TestRuns
--                                             or keep the NULL padded record
--                                             generated by the left joins if
--                                             the Programmer does not have any
--                                             TestRun!
-- Group those records by Programmer and count the TestRuns (TestRun.id)!
-- The result is:
-- ivan@gmail.com, 2 (The 2 come from Pipeline with id 2)
-- petar@gmail.com, 1 (The 1 is from the 'Service B' TestCase for Pipeline 3)
-- gosho@abv.bg, 0 (gosho@abv.bg does not have any TestRun!)  
SELECT
    Programmer.email,
    COUNT(TestRun.id) as successes
FROM
    Programmer LEFT JOIN Pipeline ON Programmer.id = Pipeline.programmer
               LEFT JOIN TestRun ON  TestRun.Pipeline = Pipeline.id
WHERE TestRun.result != 'success' OR TestRun.result IS NULL
GROUP BY Programmer.id;

-- Find all the Programmers who have not ran any Pipeline
SELECT
    Programmer.email
FROM Programmer
WHERE NOT EXISTS (
    SELECT * FROM Pipeline WHERE Pipeline.programmer = Programmer.id
);

-- Find all the Programmers who have not ran any Pipeline
SELECT
    Programmer.email
FROM Programmer
WHERE Programmer.id NOT IN (
    SELECT DISTINCT Pipeline.programmer FROM Pipeline
);
